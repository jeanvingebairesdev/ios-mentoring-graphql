# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateMovie {
  _avg: MovieAvgAggregate
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
  _sum: MovieSumAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Movie {
  createdAt: DateTime!
  description: String!
  id: Int!
  name: String!
  rating: String!
  updatedAt: DateTime!
  url: String!
}

type MovieAvgAggregate {
  id: Float
}

input MovieAvgOrderByAggregateInput {
  id: SortOrder
}

type MovieCountAggregate {
  _all: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  name: Int!
  rating: Int!
  updatedAt: Int!
  url: Int!
}

input MovieCountOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

input MovieCreateInput {
  createdAt: DateTime
  description: String!
  name: String!
  rating: String!
  updatedAt: DateTime
  url: String!
}

type MovieGroupBy {
  _avg: MovieAvgAggregate
  _count: MovieCountAggregate
  _max: MovieMaxAggregate
  _min: MovieMinAggregate
  _sum: MovieSumAggregate
  createdAt: DateTime!
  description: String!
  id: Int!
  name: String!
  rating: String!
  updatedAt: DateTime!
  url: String!
}

type MovieMaxAggregate {
  createdAt: DateTime
  description: String
  id: Int
  name: String
  rating: String
  updatedAt: DateTime
  url: String
}

input MovieMaxOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

type MovieMinAggregate {
  createdAt: DateTime
  description: String
  id: Int
  name: String
  rating: String
  updatedAt: DateTime
  url: String
}

input MovieMinOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

input MovieOrderByWithAggregationInput {
  _avg: MovieAvgOrderByAggregateInput
  _count: MovieCountOrderByAggregateInput
  _max: MovieMaxOrderByAggregateInput
  _min: MovieMinOrderByAggregateInput
  _sum: MovieSumOrderByAggregateInput
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

input MovieOrderByWithRelationInput {
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  rating: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

enum MovieScalarFieldEnum {
  createdAt
  description
  id
  name
  rating
  updatedAt
  url
}

input MovieScalarWhereWithAggregatesInput {
  AND: [MovieScalarWhereWithAggregatesInput!]
  NOT: [MovieScalarWhereWithAggregatesInput!]
  OR: [MovieScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  rating: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  url: StringWithAggregatesFilter
}

type MovieSumAggregate {
  id: Int
}

input MovieSumOrderByAggregateInput {
  id: SortOrder
}

input MovieUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input MovieUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  rating: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  createdAt: DateTimeFilter
  description: StringFilter
  id: IntFilter
  name: StringFilter
  rating: StringFilter
  updatedAt: DateTimeFilter
  url: StringFilter
}

input MovieWhereUniqueInput {
  id: Int
}

type Mutation {
  createOneMovie(data: MovieCreateInput!): Movie!
  deleteManyMovie(where: MovieWhereInput): AffectedRowsOutput!
  deleteOneMovie(where: MovieWhereUniqueInput!): Movie
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): AffectedRowsOutput!
  updateOneMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  upsertOneMovie(create: MovieCreateInput!, update: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  aggregateMovie(cursor: MovieWhereUniqueInput, orderBy: [MovieOrderByWithRelationInput!], skip: Int, take: Int, where: MovieWhereInput): AggregateMovie!
  findFirstMovie(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationInput!], skip: Int, take: Int, where: MovieWhereInput): Movie
  groupByMovie(by: [MovieScalarFieldEnum!]!, having: MovieScalarWhereWithAggregatesInput, orderBy: [MovieOrderByWithAggregationInput!], skip: Int, take: Int, where: MovieWhereInput): [MovieGroupBy!]!
  movie(where: MovieWhereUniqueInput!): Movie
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByWithRelationInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
